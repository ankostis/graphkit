# Render it manually with this command, and remember to update result in git:
#
#   dot docs/GraphtikFlowchart.dot -Tsvg -odocs/source/images/GraphtikFlowchart-vX.Y.Z.svg
#
digraph {
    label="graphtik-v4.1.0 flowchart";
    labelloc=t;

    operations  [shape=parallelogram fontname="italic" tooltip=class
                 URL="arch.html#term-operation"];
    compose     [fontname="italic" tooltip=phase
                 URL="arch.html#term-composition"];
    network     [shape=parallelogram fontname="italic" tooltip=class
                 URL="arch.html#term-network"];
    inputs      [shape=rect label="input names" tooltip=mappings
                 URL="arch.html#term-inputs"];
    outputs     [shape=rect label="output names" tooltip=mappings
                 URL="arch.html#term-outputs"];
    predicate   [shape=rect label="node predicate" tooltip=function
                 URL="arch.html#term-node-predicate"];
    subgraph cluster_compute {
        label=compute
        fontname=bold
        style=dashed
        labelloc=b
        tooltip="process, NetOp's method"
        URL="arch.html#term-compute"

        compile     [fontname="italic" tooltip="phase, Network's method"
                     URL="arch.html#term-compilation"];
        plan        [shape=parallelogram label="execution plan" fontname="italic" tooltip=class
                     URL="arch.html#term-execution-plan"];
        execute     [fontname=italic fontname="italic" tooltip="phase, Plan's method"
                     URL="arch.html#term-execution"];
    }
    values      [shape=rect label="input values" tooltip=mappings
                 URL="arch.html#term-inputs"];
    solution    [shape=parallelogram tooltip=class
                 URL="arch.html#term-solution"];

    operations -> compose -> network    [arrowhead=vee];
    {network inputs outputs predicate} -> compile -> plan  [arrowhead=vee];
    {plan values} -> execute -> solution [arrowhead=vee];
}