######################
Plotting and Debugging
######################

.. _plotting:

Plotting
--------

For :ref:`debugging` it is necessary to visualize the graph-operation.
You may plot the original plot and annotate on top the *execution plan* and
solution of the last computation, calling methods with arguments like this::

   netop.plot(show=True)              # open a matplotlib window
   netop.plot("netop.svg")            # other supported formats: png, jpg, pdf, ...
   netop.plot()                       # without arguments return a pydot.DOT object
   netop.plot(solution=solution)      # annotate graph with solution values

... or for the last ...::

   solution.plot(...)

.. image:: images/executed_3ops.svg
    :alt: execution plan

.. figure:: images/GraphtikLegend.svg
   :alt:  Graphtik Legend
   :width: 100%

   The legend for all graphtik diagrams, generated by :func:`.legend()`.

The same :meth:`.Plotter.plot()` method applies also for:

- :class:`.NetworkOperation`
- :class:`.Network`
- :class:`.ExecutionPlan`
- :class:`~.network.Solution`

each one capable to producing diagrams with increasing complexity.
Whenever possible, the top-level ``plot()`` methods will delegate to the ones below;
specifically, the :term:`netop` keeps a transient reference to the last `plan`.
BUT the `plan` does not hold such a reference, you have to plot the `solution`.

For instance, when a net-operation has just been composed, plotting it will
come out bare bone, with just the 2 types of nodes (data & operations), their
dependencies, and the sequence of the execution-plan.

.. image:: images/barebone_3ops.svg
    :alt: barebone graph

But as soon as you run it, the net plot calls will print more of the internals.
Internally it delegates to :meth:`.ExecutionPlan.plot()` of :attr:`.NetworkOperation.last_plan`
attribute, which *caches* the last run to facilitate debugging.
If you want the bare-bone diagram, plot the network::

   netop.net.plot(...)

If you want all details, plot the solution::

   solution.net.plot(...)

.. Note::
   For plots, `Graphviz <https://graphviz.org>`_ program must be in your PATH,
   and ``pydot`` & ``matplotlib`` python packages installed.
   You may install both when installing ``graphtik`` with its ``plot`` extras::

      pip install graphtik[plot]

.. Tip::
   The `pydot.Dot <https://pypi.org/project/pydot/>`_ instances returned by
   :meth:`.Plotter.plot()` are rendered directly in *Jupyter/IPython* notebooks
   as SVG images.

   You may increase the height of the SVG cell output with something like this::

        netop.plot(jupyter_render={"svg_element_styles": "height: 600px; width: 100%"})

   Check :data:`.default_jupyter_render` for defaults.


Sphinx-generated sites
^^^^^^^^^^^^^^^^^^^^^^

You may use the :rst:dir:`graphtik` directive from :mod:`.sphinxext` module
to embed graph-plots into your generated site.

.. rst:directive::  graphtik

   Embeds :ref:`graphtik plots <plotting>` from doctest code into a sphinx site.

    It supports:

    - all configurations from :mod:`sphinx.ext.doctest` sphinx-extension.
    - all options from `'doctest' directive
      <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html#directive-doctest>`_,
    - the typical options for images:

      - **height**
      - **width**
      - **scale**
      - **align**
      - **class**
      - **name**

    - and the following new options:

      .. rst:directive:option:: graphvar: (string, optional) varname
          :type: str

          the variable name containing what to render, which it can be:

          - an instance of :class:`.Plotter` (such as :class:`.NetworkOperation`,
            :class:`.Network`, :class:`.ExecutionPlan` or :class:`.Solution`);

          - an already plotted ``pydot.Dot`` instance, ie, the result of a :meth:`.plot()` call
            (see `pydot <https://github.com/pydot/pydot>`_ project).

          If missing, it renders the last variable in the doctest code assigned with
          the above types.

      .. rst:directive:option:: graph-format: png | svg | svgz | pdf | `None`
          :type: choice, default: None

          if `None`, format decided according to active builder, roughly:
              - "html"-like: svg
              - "latex": pdf

          Note that SVGs support zooming, and that PNGs suport image maps for
          linkable areas.

      .. rst:directive:option:: caption: figure's caption
          :type: str

          If given, it is used instead of rendered object's string representation.


.. rst:directive::  graphtik-output

   Like :rst:dir:`graphtik`, but applied for doctest's :rst:dir:`testoutput` blocks.


Examples
~~~~~~~~
The following directive renders a diagram of its doctest code, beneath it:

.. code-block:: rst

   .. graphtik::
      :graphvar:

      >>> from graphtik import compose, operation
      >>> addmul = compose(
      ...       "addmul",
      ...       operation(name="add", needs=["a", "b"], provides="ab")(lambda a, b: a + b),
      ...       operation(name="add", needs=["ab", "c"], provides="ab x c")(lambda a, b: a * b),
      ... )

.. graphtik::
   :graphvar: addmul
   :hide:

   >>> from graphtik import compose, operation

   >>> addmul = compose(
   ...    "addmul",
   ...    operation(name="add", needs=["a", "b"], provides="ab")(lambda a, b: a + b),
   ...    operation(name="add", needs=["ab", "c"], provides="ab x c")(lambda a, b: a * b),
   ... )

.. hint::
   In this case, the ``:graphvar:`` parameter is not really needed, since
   the code contains just one variable assignment receiving a subclass
   of :class:`.Plotter` or :class:`pydot.Dot` instance.


Configurations
~~~~~~~~~~~~~~
.. confval:: graphtik_default_graph_format

   - type: ``Union[str, None]``
   - default: None

   The file extension of the generated plot images (without the leading dot `.``),
   used  when no ``:graph-format:`` is given in a :rst:dir:`graphtik` or
   :rst:dir:`graphtik-output` directive.

   If it `None`, the format is chosen from :confval:`graphtik_graph_formats_by_builder`
   configuration.

.. confval:: graphtik_graph_formats_by_builder

   - type: ``Map[str, str]``
   - default: check the sources

   a dictionary defining which plot image formats to choose, depending on the active builder.

   - Keys are regexes matching the name of the active builder;
   - values are strings from the supported formats for `pydot`_ library,
     e.g. ``png`` (see :func:`.supported_plot_formats()`).

   If a builder does not match to any key, and no format given in the directive,
   no graphtik plot is rendered; so by default, it only generates plots for html & latex.

.. Warning::
   Don't disable doctesting of *literal-blocks*, that is,
   don't reset the :confval:`doctest_test_doctest_blocks` configuration value,
   or it will hinder your  capability to render ``:graphvar:`` from such code.

.. _debugging:

Errors & debugging
------------------

Graphs may become arbitrary deep.  Launching a debugger-session to inspect
deeply nested stacks is notoriously hard

As a workaround, you may increase the logging verbosity.

.. tip::
   The various :mod:`.network` objects print augmented string-representations
   when :data:`graphtik.network.log` :class:`~logging.Logger` is *eventually*
   DEBUG-enabled.

Additionally, when some operation fails, the original exception gets annotated
with the following properties, as a debug aid:

>>> from graphtik import compose, operation
>>> from pprint import pprint

>>> def scream(*args):
...     raise ValueError("Wrong!")

>>> try:
...     compose("errgraph",
...             operation(name="screamer", needs=['a'], provides=["foo"])(scream)
...     )(a=None)
... except ValueError as ex:
...     pprint(ex.jetsam)
{'aliases': None,
 'args': {'kwargs': {}, 'positional': [None], 'varargs': []},
 'network': Network(x3 nodes, x1 ops:
    +--a
    +--FunctionalOperation(name='screamer', needs=['a'], provides=['foo'], fn='scream')
    +--foo),
 'operation': FunctionalOperation(name='screamer', needs=['a'], provides=['foo'], fn='scream'),
 'outputs': None,
 'plan': ExecutionPlan(needs=['a'], provides=['foo'], x1 steps:
  +--FunctionalOperation(name='screamer', needs=['a'], provides=['foo'], fn='scream')),
 'provides': None,
 'results_fn': None,
 'results_op': None,
 'solution': {'a': None},
 'task': OpTask(FunctionalOperation(name='screamer', needs=['a'], provides=['foo'], fn='scream'), sol_keys=['a'])}


In interactive *REPL* console you may use this to get the last raised exception::

     import sys

     sys.last_value.jetsam


The following annotated attributes *might* have meaningful value on an exception:

``network``
   the innermost network owning the failed operation/function

``plan``
   the innermost plan that executing when a operation crashed

``operation``
   the innermost operation that failed

``args``
    either the input arguments list fed into the function, or a dict with
    both ``args`` & ``kwargs`` keys in it.

``outputs``
    the names of the outputs the function was expected to return

``provides``
    the names eventually the graph needed from the operation;
    a subset of the above, and not always what has been declared in the operation.

``fn_results``
    the raw results of the operation's function, if any

``op_results``
    the results, always a dictionary, as matched with operation's `provides`

``solution``
    an instance of :class:`.Solution`, contains `inputs` & `outputs` till the error happened;
    note that :attr:`.Solution.executed` contain the list of executed `operations` so far.

Of course you may use many of the above "jetsam" values when plotting.

.. note::
   The :ref:`plotting` capabilities, along with the above annotation of exceptions
   with the internal state of plan/operation often renders a debugger session
   unnecessary.  But since the state of the annotated values might be incomplete,
   you may not always avoid one.
